//===-- Executor.cpp ------------------------------------------------------===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "Executor.h"
#include "Context.h"
#include "CoreStats.h"
#include "ExternalDispatcher.h"
#include "ImpliedValue.h"
#include "Memory.h"
#include "MemoryManager.h"
#include "PTree.h"
#include "Searcher.h"
#include "SeedInfo.h"
#include "SpecialFunctionHandler.h"
#include "StatsTracker.h"
#include "TimingSolver.h"
#include "UserSearcher.h"
#include "ExecutorTimerInfo.h"

#include "../Solver/Z3Solver.h"

#include "klee/ExecutionState.h"
#include "klee/Expr.h"
#include "klee/Interpreter.h"
#include "klee/TimerStatIncrementer.h"
#include "klee/CommandLine.h"
#include "klee/Common.h"
#include "klee/util/Assignment.h"
#include "klee/util/ExprPPrinter.h"
#include "klee/util/ExprSMTLIBPrinter.h"
#include "klee/util/ExprUtil.h"
#include "klee/util/GetElementPtrTypeIterator.h"
#include "klee/Config/Version.h"
#include "klee/Internal/ADT/KTest.h"
#include "klee/Internal/ADT/RNG.h"
#include "klee/Internal/Module/Cell.h"
#include "klee/Internal/Module/InstructionInfoTable.h"
#include "klee/Internal/Module/KInstruction.h"
#include "klee/Internal/Module/KModule.h"
#include "klee/Internal/Support/ErrorHandling.h"
#include "klee/Internal/Support/FloatEvaluation.h"
#include "klee/Internal/Support/ModuleUtil.h"
#include "klee/Internal/System/Time.h"
#include "klee/Internal/System/MemoryUsage.h"
#include "klee/SolverStats.h"
#include "klee/sysrel.h"
#include "klee/SolverImpl.h"

#include "llvm/IR/Function.h"
#include "llvm/IR/Attributes.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/TypeBuilder.h"
#include "llvm/IR/TypeFinder.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/DerivedTypes.h"

#if LLVM_VERSION_CODE < LLVM_VERSION(3, 5)
#include "llvm/Support/CallSite.h"
#else
#include "llvm/IR/CallSite.h"
#endif

#ifdef HAVE_ZLIB_H
#include "klee/Internal/Support/CompressionStream.h"
#endif

#include <cassert>
#include <algorithm>
#include <iomanip>
#include <iosfwd>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>

#include <sys/mman.h>

#include <errno.h>
#include <cxxabi.h>

#include "llvm/IR/InlineAsm.h"
#include "ResourceUsage.h"
#include "AnalyzeConstraint.h"

using namespace llvm;
using namespace klee;

/* SYSREL extension */

bool symbolizeInlineAssembly = false;

bool skipOptimizingSensitiveRegionCheck = false;

//#define INFOFLOW 1

extern std::set<std::string> voidTypeCasts;
size_t maxVoidTypeCastSize = 8;
std::set<std::string> reached;

/* Side channel begin */
// Type hints for void function args
std::map<std::string, std::map<unsigned int, std::vector<unsigned int> > > externalFuncsWithSensitiveFlow;
std::map<std::string, unsigned int> externalFuncs;
std::map<std::string, std::set<unsigned int> > externalFuncsSig;
std::map<std::string, std::map<int, std::string> > funcArgTypeHints;
extern std::set<std::pair<std::string, int>> cachelocs;
extern std::set<std::pair<std::string, int>> codeCachelocs;
extern unsigned long cacheLineBits;
extern bool cacheLineMode;
extern bool cacheBitmaskMode;
extern unsigned int cacheBitmask;
//  Functions that receive input from the environment
std::set<std::string> inputFuncs;
std::map<std::string, std::set<unsigned int> > inputFuncArgs;
// Maps function arguments to its high security regions
std::map<std::string, std::set<int> > highFunctionArgs;
// Maps function arguments to its low security regions
std::map<std::string, std::set<int> > lowFunctionArgs;  
// Maps function arguments to its mixed security regions
std::map<std::string, std::set<int> > mixedFunctionArgs;  
// Maps function arguments to its high security regions
std::map<std::string, std::set<int> > highFunctionArgsRet;
// Maps function arguments to its low security regions
std::map<std::string, std::set<int> > lowFunctionArgsRet;  
// Maps function arguments to its mixed security regions
std::map<std::string, std::set<int> > mixedFunctionArgsRet; 
// Maps types to its high security regions
std::map<std::string, std::vector<region> > highTypeRegions;
// Maps types to its low security regions
std::map<std::string, std::vector<region> > lowTypeRegions;
// Maps symbolic regions to its high security regions
// unique symbolic names eliminate the need to do the mapping per state
std::map<std::string, std::vector<region> > highSymRegions;
// Maps symbolic regions to its low security regions
// unique symbolic names eliminate the need to do the mapping per state
std::map<std::string, std::vector<region> > lowSymRegions;
// Maps addresses of ExecutionState's to addresses of high security sensitive regions
// regions provide precise tracking of subregions
std::map<long, std::map<ref<Expr>, std::vector<region> > > highMemoryRegions;
// Maps addresses of ExecutionState's to addresses of low security sensitive regions
// regions provide precise tracking of subregions
std::map<long, std::map<ref<Expr>, std::vector<region> > > lowMemoryRegions;
std::map<long, klee::ref<Expr> > branchConditionMap;
std::map<long, llvm::Instruction*> branchInstrMap;
std::set<klee::ExecutionState*> * successorsPaths = new std::set<klee::ExecutionState*>();
extern std::string entryFunctionName;
//extern std::map<std::string, std::set<int> > dynamicHighLoc, dynamicLowLoc;
extern std::map<std::string, std::map<int, std::vector<region> > > dynamicHighRegion, dynamicLowRegion;
std::string publicOutputVarName = "return_value";
std::string publicOutputReturningFName;
ref<Expr> publicOutputVar;
extern std::string sidechannelentry;
bool sidechannelstarted = false;
extern std::set<std::string> * highLoc;
extern std::set<std::string> * lowLoc;
extern std::map<int, RD*> * rdmap;
extern std::vector<std::string> * untrusted;
extern std::set<std::string> prefixRedact;
std::set<RD*> resourceTreeRootList;
RD *root;
RD *currentRD;
std::vector<ExecutionState *> addedStates_copy;
std::vector<ExecutionState *> removedStates_copy;
bool fset = false;
Function *ff;
ArrayCache *acache = NULL;
//int maxForkMulRes = 10;
int maxForkMulRes = 2147483647;
int primArraySize = 32;
int leakCheckOffset = 64;
std::map<std::string, int> uniqueSym;
std::set<std::string> highSecurityLeaksOnStack;
std::set<std::string> codeLocHighSecurityLeaksOnStack;
std::set<std::string> stackLeakToBeChecked;
bool checkLeaksPreciseAndFocused = false;
std::set<std::string> securitySensitiveBranches;
std::map<std::string, int> inputFuncsSuccRetValue;
std::set<long> updatedWithSymbolic;
std::set<unsigned> secretDependentRUSet;
std::map<unsigned, unsigned> secretDependentRUMap;
std::map<unsigned, std::vector<ConstraintManager> > secretDependentRUConstMap;
std::string infoFlowSummarizedFuncName;
Function *infoFlowSummarizedFunc = NULL;
bool leakageWMaxSat = false;
unsigned leakageMaxSat = 0;
unsigned numSecretDependent=0;
unsigned numSecretIndependent=0;
bool pauseSecretIndependent = false;
std::set<long> statesWithCorruptedPC;
extern void recordMemObj(ExecutionState &state, const MemoryObject *mo);
std::map<std::string, std::set<int> > ocallFuncPtrMap;
std::set<std::string> timingObservationPointCaller;
std::map<std::string, int> reachabilityTimingObservationPoints;
std::map<long, std::map<std::string, unsigned> > forkFreqMapTrue;
std::map<long, std::map<std::string, unsigned> > forkFreqMapFalse;
std::set<std::string> loopBoundExceptions;
unsigned loopBound = 0;
std::map<std::string, std::map<unsigned, 
         std::pair<unsigned, unsigned> > > dataConstraintMap;

std::string getTypeName(Type *t);

bool getDataConstraint(std::string tname, unsigned offset, 
                                  std::pair<unsigned, unsigned> &fieldinfo) {
     for(auto mi : dataConstraintMap) {
        if (mi.first.find(tname) != std::string::npos || 
               tname.find(mi.first) != std::string::npos) {
           std::map<unsigned, std::pair<unsigned, unsigned> > map = mi.second;
           if (map.find(offset) != map.end()) {
              fieldinfo = map[offset];
              return true;
           }
           else return false;
        }
     }  
     return false;
}

Type *getEnclosingObjectType(Instruction *inst) {
   std::vector<Value *>  wl;
   LoadInst *li = dyn_cast<LoadInst>(inst);
   if (!li) assert(0 && "bitcast info must be computed for load instructions!");
   Type *result = NULL;
   std::set<Value*> seen;
   wl.push_back(li);
   while (wl.size() > 0) {
      Value *val = wl.back();
      seen.insert(val);
      wl.pop_back();
      Instruction *ti = dyn_cast<Instruction>(val);
      if (!ti) continue;
      //llvm::errs() << "traversing " << (*ti) << "\n";
      switch (ti->getOpcode()) {
        case Instruction::Load: {
           if (ti != li) {
              result = ti->getType();
              if (result->isPointerTy()) {
                 result = result->getPointerElementType();
                 if (result->isPointerTy()) {
                    result = result->getPointerElementType(); 
                 }
              }
              StructType *st = dyn_cast<StructType>(result);
              if (st) 
                 return result; 
              else return NULL;
           }
        }
        default: {
          for(unsigned int i=0; i<ti->getNumOperands(); i++) {
             if (seen.find(ti->getOperand(i)) == seen.end())
                wl.push_back(ti->getOperand(i));
          }
        }
      }      
   }
   return result;
}


bool isLoopBoundExcluded(std::string s) {
  for(auto se : loopBoundExceptions) {
     if (s.find(se) != std::string::npos) return true; 
  }
  return false;
}

void addForkFreq(ExecutionState &state, std::string inst, bool isTrue) {
  long s = (long)&state;
  std::map<std::string, unsigned> m;
  if (isTrue) {
     if (forkFreqMapTrue.find(s) != forkFreqMapTrue.end()) 
        m = forkFreqMapTrue[s];
     if (m.find(inst) != m.end()) 
        m[inst] = m[inst] + 1;
     else 
        m[inst] = 1;
     forkFreqMapTrue[s] = m;
  }
  else {
     if (forkFreqMapFalse.find(s) != forkFreqMapFalse.end()) 
        m = forkFreqMapFalse[s];
     if (m.find(inst) != m.end()) 
        m[inst] = m[inst] + 1;
     else 
        m[inst] = 1;
     forkFreqMapFalse[s] = m;  
  }
}

unsigned getForkFreq(ExecutionState &state, std::string inst, bool isTrue) {
  long s = (long)&state;
  std::map<std::string, unsigned> m;
  //llvm::errs() << "fork freq for " << inst << "\n";
  if (isTrue) {
     if (forkFreqMapTrue.find(s) != forkFreqMapTrue.end()) 
        m = forkFreqMapTrue[s];
     if (m.find(inst) != m.end()) 
        return m[inst];
     else return 0;
  }
  else {
     if (forkFreqMapFalse.find(s) != forkFreqMapFalse.end()) 
        m = forkFreqMapFalse[s];
     if (m.find(inst) != m.end()) 
        return m[inst];
     else return 0; 
  }
}

std::string getStackTrace(ExecutionState &state) {
    std::string MsgString;
    llvm::raw_string_ostream msg(MsgString);
    state.dumpStack(msg);
    return msg.str();
}

std::string getSouceWithContext(ExecutionState &state, KInstruction *ki) {
   std::string swctx = getStackTrace(state);
   llvm::errs() << "stack trace=" << swctx << "\n";
   swctx = swctx + ki->getSourceLocation();
   return swctx;
}

bool isATimingObservationFuncPtr(std::string tname, int value) {
   if (tname[0] == '%')
      tname = tname.substr(1);
   if (ocallFuncPtrMap.find(tname) == ocallFuncPtrMap.end())
      return false;
   if (ocallFuncPtrMap[tname].find(value) == ocallFuncPtrMap[tname].end())
      return false;
   return true;
}

void checkTimingObservationFuncPtr(Value *value) {
   if (!isa<Instruction>(value)) return;
   Instruction *inst = (Instruction*)value;
   switch (inst->getOpcode()) {
     case Instruction::BitCast:
        checkTimingObservationFuncPtr(inst->getOperand(0));     
     case Instruction::GetElementPtr: {
        GetElementPtrInst *gep = static_cast<GetElementPtrInst*>(inst);
        if (gep) {
           //llvm::errs() << "gep: " << (*gep) << "\n";
           int index = 0;
           for(User::op_iterator oi = gep->idx_begin(), oe = gep->idx_end(); oi != oe; oi++, index++) {
              if (index > 1) break;
              else if (index == 0) continue; 
              Value *v = oi->get();
              if (llvm::ConstantInt* CI = dyn_cast<llvm::ConstantInt>(v)) {
                 Type *t = gep->getSourceElementType();
                 if (t) {
                    if (t->isPointerTy()) 
                       t = t->getPointerElementType();
                    std::string tname = getTypeName(t);
                    if (CI->getSExtValue() >= 0 && isATimingObservationFuncPtr(tname, CI->getSExtValue())) {
                       llvm::errs() << "function " << inst->getParent()->getParent()->getName() << " calls timing observation point " << tname << " field " <<  CI->getSExtValue() << "\n";
                       timingObservationPointCaller.insert(inst->getParent()->getParent()->getName());
                       
                    } 
                 }
              }
           }
        }     
        break;
     }
     case Instruction::Load: {
        LoadInst *linst = static_cast<LoadInst*>(inst);
        checkTimingObservationFuncPtr(linst->getPointerOperand());
     }
     default:       
        return;
   }
}


bool isIndirectCall(CallSite *cs) {
   const Value *V = cs->getCalledValue();
   if (isa<Function>(V) || isa<Constant>(V))
     return false;
   if (const CallInst *CI = dyn_cast<CallInst>(V))
     if (CI->isInlineAsm())
       return false;
  return true;
}


void extractFunctionsCallingTimingObservationPoints(KModule *kmodule) {
    
   for (Module::iterator F = kmodule->module->begin(); F != kmodule->module->end(); F++) {
       for (Function::iterator bb = F->begin(), e = F->end(); bb != e; ++bb) {
           for (BasicBlock::iterator i = bb->begin(), e = bb->end(); i != e; ++i) {
               Instruction &ii = *i;
               switch (ii.getOpcode()) {
                 case Instruction::Invoke:
                 case Instruction::Call: {
                    CallSite cs(&ii);
                    if (isIndirectCall(&cs)) {
                       checkTimingObservationFuncPtr(cs.getCalledValue());
                    }
                    break;
                 }
                 default: continue;
               }
           }
       }
   }
}

void Executor::recordMostRecentBranchInfo(ExecutionState &state, llvm::Instruction *brinst) {
  long sid = (long)&state;
  branchInstrMap[sid] = brinst;     
  //llvm::errs() << "Recorded most recent branch as " << (*brinst) << "\n";
}

void Executor::getMostRecentBranchInfo(ExecutionState &state, llvm::Instruction *&brinst, bool &found) {
  long sid = (long)&state;
  if (branchInstrMap.find(sid) == branchInstrMap.end()) {
     found = false;
     return;
  }
  brinst = branchInstrMap[sid];
  found = true;
  //llvm::errs() << "Most recent branch: " << (*brinst) << "\n"; 
}

//#ifdef INFOFLOW
// InfoFlowSummarization
struct infoflowdata {
  std::map<unsigned int, const MemoryObject*> *regMap;
  std::map<unsigned int, std::map<region, std::set<InfoFlowRegion_t> > > *localIFlow;
};
typedef struct infoflowdata infoflowdata_t;
std::map<ExecutionState*, std::vector<infoflowdata_t>* > infoflowstack;
infoflowdata_t currentInfoFlowContext;
std::map<ExecutionState*, 
         std::map<const MemoryObject*, 
                  std::map<region, 
                           std::set<InfoFlowRegion_t> > > > memoryInfoFlow;
// Maps info flow relevant memory objects to ids that are meaningful to the client, e.g., argument indices of a summarized function
std::map<int, int> argRegsInfoFlow;
// dest index to dest memory region to source memory regions 
std::map<int, std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > >  infoFlowSummary;
std::map<ExecutionState*, std::map<int, std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > > > infoFlowSummaryPerState;

/*
bool operator<(const region r1, const region r2) {
  if (r1.offset == r2.offset)
     return r1.size < r2.size;
  else if (r1.size == r2.size) 
     return r2.offset < r2.offset;
  else r1.offset + r1.size  < r2.offset + r2.size;
}*/

namespace std {
bool operator<(const InfoFlowRegion_t ifr1, const InfoFlowRegion_t ifr2) {
   if (ifr1.index < ifr2.index)
      return true;
   else if (ifr1.index == ifr2.index) {
      if (ifr1.regions.size() < ifr2.regions.size())
         return true;
      else if (ifr1.regions.size() > ifr2.regions.size())
         return false;
      else {
         for(unsigned int i=0; i<ifr1.regions.size(); i++)
            if (ifr1.regions[i] < ifr2.regions[i])
               return true;
         return false; 
      }
   } 
   else return false;
}
}

//#endif

/* Side channel end */

//#define VBSC

#define ASYNC_STR "async_initiate"
#define ENABLE_STR "enable_entry"
//#define PRIM_LAZY_INIT_SIZE  64
//#define PRIM_LAZY_INIT_SIZE  32
#define STRUCT_LAZY_INIT_INS 10
// this is to avoid assertion failure
// represents size in bits so SIZE_FOR_UNTYPED (2000) * 8
#define SIZE_FOR_UNKNOWN_TYPES 8*8
int MAX_ALLOC_SIZE=10240;

cl::opt<bool>
CheckInfoFlowRule("check-infoflow", cl::desc("Checks and reports information flows from high labeled memory to low labeled memory\n"));

cl::opt<bool>
InitFuncPtrs("init-funcptr-fields" , cl::desc("Set function pointer fields to null when lazy initializing struct type objects"),
             cl::init(false));


cl::opt<bool>
BreakSelectStmt("fork-for-select", cl::desc("Fork states to simulate the select statement\n"),
           cl::init(false));

cl::opt<bool>
PreferredResolution("use-one-for-resol", cl::desc("Use the candidate memory object stored for the relevant symbolic \ 
                                  address expression for symbolic address resolution!\n"), cl::init(false));
std::map<long, std::map<ref<Expr>, const MemoryObject *> > addressToMemObj;
std::map<long, std::map<ref<Expr>, ref<Expr> > > symIndexToMemBase;
extern std::set<std::string> assemblyFunctions;



KModule *kmoduleExt;
llvm::Function *entryFunc;
extern const Module * moduleHandle;
extern bool asyncMode;
extern std::vector<std::string> asyncFunc;
extern std::vector<std::string> enabledFunc;
extern APIHandler *apiHandler;
extern bool progModel;
extern std::map<std::string, std::map<unsigned int, int> > lazyInitInitializersWValues;
extern std::map<std::string, std::vector<unsigned int> > lazyInitInitializers;
extern std::map<std::string, std::map<unsigned int, std::string> > lazyFuncPtrInitializers;

std::string getAsyncFunction(std::string fn) {

  return fn.substr(fn.find(ASYNC_STR) + strlen(ASYNC_STR) + 1, fn.size());
}

std::string getEnableFunction(std::string fn) {

  return fn.substr(fn.find(ENABLE_STR) + strlen(ENABLE_STR) + 1, fn.size());
}

bool isAssemblyFunc(std::string name) {
  for(auto af : assemblyFunctions)
     if (af == name)
        return true;
  return false;
}

extern int minInstCount;
extern int maxInstCount;

extern bool lazyInit;
extern bool lazySpec;
extern int numLazyInst;
extern std::vector<std::string> lazyInits;
extern std::set<std::string> lazyInitSingles;
extern std::map<std::string, int> lazyInitNumInstances;
//std::set<std::string> embeddedTypes;
std::set<Type*> embeddedTypes;
//std::map<std::string, std::set<std::string> >  embeddings;
std::map<Type*, std::set<Type*> >  embeddingTypes;
bool singleSuccessor = true;


bool infoFlowSummaryMode = false;


//#ifdef INFOFLOW
/* InfoFlowSummarization */

region adjustment(region r1, region r2);

std::set<InfoFlowRegion_t> adjust(std::set<InfoFlowRegion_t> ifrs, region adj);

std::vector<region> diffPartitionRegion(region r1, std::vector<region> rgs);

std::map<region, std::set<InfoFlowRegion_t> > slice(std::map<region, std::set<InfoFlowRegion_t> > ifrmap, region rt);

std::set<InfoFlowRegion_t> setIF(InfoFlowRegion_t &ifr) {
  std::set<InfoFlowRegion_t> res;
  res.insert(ifr);
  return res;
}

void print(const InfoFlowRegion_t &ifr) {
  llvm::errs() << ifr.index << ",";
  for(unsigned int i=0; i<ifr.regions.size(); i++)
     llvm::errs() << "[" << ifr.regions[i].offset << ":" << ifr.regions[i].size << "]";
}

void print(std::fstream &fstr, const InfoFlowRegion_t &ifr) {
  fstr << ifr.index << ",";
  for(unsigned int i=0; i<ifr.regions.size(); i++)
     fstr << "[" << ifr.regions[i].offset << ":" << ifr.regions[i].size << "]";
}

void print(std::set<InfoFlowRegion_t> ifrs) {
  llvm::errs() << "{";
  unsigned int i=0;
  for(auto ifr : ifrs) {
     print(ifr);
     if (i < ifrs.size() - 1)
        llvm::errs() << "\n";
  }
  llvm::errs() << "}\n";
  
}

void print(std::fstream &fstr, std::set<InfoFlowRegion_t> ifrs) {
  fstr << "{";
  unsigned int i=0;
  for(auto ifr : ifrs) {
     print(fstr, ifr);
     if (i < ifrs.size() - 1)
        fstr << "\n";
  }
  fstr << "}\n";
  
}



void dumpInfoFlow() {
  llvm::errs() << "Info Flow Summary for function " << infoFlowSummarizedFuncName << "\n"; 
  for(auto ifse : infoFlowSummary) {
     for(auto ifse2 : ifse.second) {
           print(ifse2.second);
           llvm::errs() << "\t===>\n";
           print(ifse2.first);
           llvm::errs() << "\n\n";
     }
  }
}

void writeInfoFlowSummary(const char *fname) {
   std::fstream rc(fname, std::fstream::out);
   if (rc.is_open()) {
      for(auto ifse : infoFlowSummary) {
         for(auto ifse2 : ifse.second) {
            print(rc, ifse2.second);
            rc << "=>\n";
            print(rc, ifse2.first);
            rc << "\n"; 
         }
      }
      rc.close();
   }
}

void readInfoFlowSummary(char *fname){
}


bool isLocal(int reg) {
   return (currentInfoFlowContext.regMap->find(reg) != currentInfoFlowContext.regMap->end());
}

void Executor::recordArgRegisters(Function *f) {
   KFunction *kf = kmodule->functionMap[f];
   unsigned int argi = 0;
   for(llvm::Function::arg_iterator ai = f->arg_begin(); ai != f->arg_end(); ai++, argi++) {
      argRegsInfoFlow[kf->getArgRegister(argi)] = argi;
      llvm::errs() << "recording arg " << argi << " and the register " << kf->getArgRegister(argi) << " as info flow relevant in " << f->getName() << "\n"; 
   }     
}

int isInfoFlowRelevant(KInstruction *ki, int regIndex) {
   Function *f = ki->inst->getParent()->getParent();
   if (f == infoFlowSummarizedFunc) {
      if (argRegsInfoFlow.find(regIndex) != argRegsInfoFlow.end())
         return argRegsInfoFlow[regIndex];
      else return -1; 
   }
   else return -1;
}

int getLocal(ExecutionState &state, KInstruction *ki, int index) {
  assert(index >=0 && index < ki->inst->getNumOperands());
  int vnumber = ki->operands[index];
  return vnumber;
}

void initInfoFlowContext(ExecutionState &state) {
   if (!infoFlowSummaryMode) return;
   infoflowdata_t initvalue;
   initvalue.regMap = new std::map<unsigned int, const MemoryObject*>();
   initvalue.localIFlow = new std::map<unsigned int, std::map<region, std::set<InfoFlowRegion_t> > >();
   std::vector<infoflowdata_t> *ctxstack = new std::vector<infoflowdata_t>();
   currentInfoFlowContext = initvalue;
   ctxstack->push_back(initvalue);
   infoflowstack[&state] = ctxstack;
   llvm::errs() << "init info flow context for " << &state << "\n"; 
}

void cloneInfoFlowContext(ExecutionState &state1, ExecutionState &state2) {
    if (!infoFlowSummaryMode) return;
    std::vector<infoflowdata_t>  *cpstack = new std::vector<infoflowdata_t>();
    for(unsigned int i=0; i< infoflowstack[&state1]->size(); i++)  
       cpstack->push_back((*infoflowstack[&state1])[i]);
    infoflowstack[&state2] = cpstack;
    memoryInfoFlow[&state2] = memoryInfoFlow[&state1];
    llvm::errs() << "cloning info flow context from " << &state1 << " to " << &state2 << "\n";
}

void updateCurrentInfoFlowContext(ExecutionState &state) {
  if (!infoFlowSummaryMode) return;
  int last = infoflowstack[&state]->size() - 1; 
  currentInfoFlowContext = (*infoflowstack[&state])[last];
  llvm::errs() << "switching to state " << &state << "\n";
}

void pushInfoFlowContext(ExecutionState &state) {
   if (!infoFlowSummaryMode) return;
   int last = infoflowstack[&state]->size() - 1;
   (*infoflowstack[&state])[last] = currentInfoFlowContext;
   infoflowdata_t initvalue;
   initvalue.regMap = new std::map<unsigned int, const MemoryObject*>();
   initvalue.localIFlow = new std::map<unsigned int, std::map<region, std::set<InfoFlowRegion_t> > >();
   infoflowstack[&state]->push_back(initvalue);
   currentInfoFlowContext = initvalue;
   llvm::errs() << "pushing info flow context for " << &state << "\n";
}

void popInfoFlowContext(ExecutionState &state) {
   if (!infoFlowSummaryMode) return; 
   infoflowstack[&state]->pop_back();
   currentInfoFlowContext =  infoflowstack[&state]->back();
   llvm::errs() << "poping info flow context for " << &state << "\n";
}

void saveInfoFlowContext(ExecutionState &state) {
   if (!infoFlowSummaryMode) return;
   int last = infoflowstack[&state]->size() - 1;
   (*infoflowstack[&state])[last] = currentInfoFlowContext;       
   llvm::errs() << "saving info flow context for " << &state << "\n"; 
}

bool operator==(region r1, region r2) {
  return ((r1.offset == r2.offset) && (r1.size == r2.size));
}

int getRegIndexFor(const MemoryObject *mo) {
  for(auto me : (*currentInfoFlowContext.regMap)) {
     if (me.second == mo)
        return me.first;
  }  
  return -1;
}

InfoFlowRegion_t createInfoFlowRegion(int source, unsigned int offset, unsigned int size) { 
    InfoFlowRegion_t ifr;
    ifr.index = source;
    region r;
    r.offset = offset;
    r.size = size;
    ifr.regions.push_back(r);
    return ifr;
}

void addLevel(InfoFlowRegion_t &dc, unsigned int offset, unsigned int size) {
   llvm::errs() << "adding a point of indirection to ";
   print(dc);
   llvm::errs() << "\n";
   region r;
   r.offset = offset;
   r.size = size;
   dc.regions.push_back(r);
}

std::set<InfoFlowRegion_t> addLevel(std::set<InfoFlowRegion_t> dcs, unsigned int offset, unsigned int size) {
    std::set<InfoFlowRegion_t> res;
    for(auto dc : dcs) {
       InfoFlowRegion_t dci;
       dci.index = dc.index;
       for(unsigned int i=0; i<dc.regions.size(); i++)
          dci.regions.push_back(dc.regions[i]);
       addLevel(dci, offset, size);
       res.insert(dci);
    } 
    print(res);
    return res;
}


void partitionAndUpdateIFlow(std::map<region, std::set<InfoFlowRegion_t> > &ifrmap, 
                                          region rt, std::set<InfoFlowRegion_t> ifrc, bool replace);


void recordInfoFlow(InfoFlowRegion_t dest, std::set<InfoFlowRegion_t> sourceif) {
  int desti  = dest.index;
  std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > ifsmap;
  std::set<InfoFlowRegion_t>sources;  
  if (infoFlowSummary.find(desti) != infoFlowSummary.end())
      ifsmap = infoFlowSummary[desti];
  if (ifsmap.find(dest) != ifsmap.end())
     sources = ifsmap[dest];
  for(auto se : sourceif)
     sources.insert(se);
  ifsmap[dest] = sources;
  infoFlowSummary[desti] = ifsmap;
}  

void collectInfoFlow() {
  for(auto ifse : infoFlowSummaryPerState) 
     for(auto ifse2 : ifse.second) 
        for(auto ifse3 : ifse2.second) 
           recordInfoFlow(ifse3.first, ifse3.second);
  
}

void clearInfoFlowSummaryPerState(ExecutionState &state, InfoFlowRegion_t dest) {
  int desti  = dest.index;
  std::map<int, std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > > ifsmapt; 
  std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > ifsmap;
  std::set<InfoFlowRegion_t>sources;  
  if (infoFlowSummaryPerState.find(&state) != infoFlowSummaryPerState.end())
      ifsmapt = infoFlowSummaryPerState[&state];
  if (ifsmapt.find(desti) != ifsmapt.end()) {
      ifsmap = ifsmapt[desti];
  }
  if (ifsmap.find(dest) == ifsmap.end())
     return;
  ifsmap.erase(dest);
  ifsmapt[desti] = ifsmap; 
  infoFlowSummaryPerState[&state] = ifsmapt;
}

void recordInfoFlow(ExecutionState &state, InfoFlowRegion_t dest, InfoFlowRegion_t sourceif) {
  int desti  = dest.index;
  std::map<int, std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > > ifsmapt; 
  std::map<InfoFlowRegion_t, std::set<InfoFlowRegion_t> > ifsmap;
  std::set<InfoFlowRegion_t>sources;  
  if (infoFlowSummaryPerState.find(&state) != infoFlowSummaryPerState.end())
      ifsmapt = infoFlowSummaryPerState[&state];
  if (ifsmapt.find(desti) != ifsmapt.end()) {
      ifsmap = ifsmapt[desti];
  }
  //if (ifsmap.find(srci) != ifsmap.end())
  //    ifsmaprg = ifsmap[srci];
  if (ifsmap.find(dest) != ifsmap.end())
     sources = ifsmap[dest];
  sources.insert(sourceif);
  ifsmap[dest] = sources;
  ifsmapt[desti] = ifsmap; 
  infoFlowSummaryPerState[&state] = ifsmapt;
  llvm::errs() << "RECORDING info flow to destination=" << desti << "\n";
  print(sources);
  llvm::errs() << "===>\n";
  print(dest);
  llvm::errs() << "\n";
}

/*void checkAndMarkPointerRegForLoad(ExecutionState &state, KInstruction *target, int destregIndex) {
   bool doublepointer = false;
   llvm::LoadInst *li = dyn_cast<llvm::LoadInst>(target->inst);
   assert(li);
   Type *t = li->getPointerOperand()->getType();
   if (t->isPointerTy()) {
      t = t->getPointerElementType();
      if (t->isPointerTy())
            doublepointer = true;
   }
   if (doublepointer) {
      std::set<unsigned int> prs = currentInfoFlowContext.pointerRegs;
      prs.insert(destregIndex);
      currentInfoFlowContext.pointerRegs = prs; 
   }
}

void checkAndMarkPointerRegForStore(ExecutionState &state, KInstruction *target, int destregIndex) {
   bool doublepointer = false;
   llvm::StoreInst *li = dyn_cast<llvm::StoreInst>(target->inst);
   if (li) {
      Type *t = li->getPointerOperand()->getType();
      if (t->isPointerTy()) {
         t = t->getPointerElementType();
         if (t->isPointerTy())
            doublepointer = true;
      }
      if (doublepointer) {
         std::set<unsigned int> prs = currentInfoFlowContext.pointerRegs;
         prs.insert(destregIndex);
         currentInfoFlowContext.pointerRegs = prs;
      }
  }
}*/


/* Information may flow the memory location that is read or 
   from the information source represented by the address stored on the register that holds the address*/
void Executor::updateInfoFlowForLoad(ExecutionState &state, 
                                    int regIndex, 
                                int destregIndex, 
                                const MemoryObject *mo, 
                            KInstruction *target, 
                            ref<Expr> offsetexpr, 
                                   unsigned size) {
   if (!infoFlowSummaryMode) return;
   ConstantExpr *CE = dyn_cast<ConstantExpr>(offsetexpr);
   unsigned offset;
   if (!CE) { 
      // conservative approximation when offset is symbolic
      offset = 0;
      size = mo->size;
      llvm::errs() << "handling symbolic offset by conservatively using 0 and " << mo->size << "for size\n"; 
   }
   else offset = CE->getZExtValue();
   int sourceIndex = getRegIndexFor(mo);
   region rt;
   rt.offset = 0;
   rt.size = size;
   region rs;
   rs.offset = offset;
   rs.size = size;

   bool doublepointer = false;
   llvm::LoadInst *li = dyn_cast<llvm::LoadInst>(target->inst);
   assert(li);
   Type *t = li->getPointerOperand()->getType();
   if (t->isPointerTy()) {
      t = t->getPointerElementType();
      if (t->isPointerTy())
            doublepointer = true;
   }
   llvm::errs() << "Info Flow For LOAD register=" << regIndex << " offset=" << offset << " size=" << size << "\n";
   std::map<const MemoryObject*, 
                  std::map<region, 
                           std::set<InfoFlowRegion_t> > > memoryIFlow = memoryInfoFlow[&state];
   bool update = false;
   std::vector<region> updated;
   if (memoryIFlow.find(mo) != memoryIFlow.end()) {
         llvm::errs() << "Transferring info in LOAD: " << target->inst << "\n";
         llvm::errs() << "source register=" << regIndex << "\n"; 
         std::map<region, std::set<InfoFlowRegion_t> > ifrmaps =  slice(memoryIFlow[mo], rs);  
         std::map<region, std::set<InfoFlowRegion_t> > ifrmap = (*currentInfoFlowContext.localIFlow)[target->dest];         
         for(auto me : ifrmaps) {
            std::set<InfoFlowRegion_t> dc = me.second;
            if (!isLocal(regIndex))
               dc = addLevel(dc, offset, size);
            partitionAndUpdateIFlow(ifrmap, me.first, dc, true);
            updated.push_back(me.first);
         }
         (*currentInfoFlowContext.localIFlow)[target->dest] = ifrmap;
   }
   std::vector<region> notupdated = diffPartitionRegion(rt, updated);
   if (notupdated.size() > 0) {
      llvm::errs() << "Trying to fill uncovered " << notupdated.size() << " regions in LOAD after handling flow from memory\n";
      int source = isInfoFlowRelevant(target, regIndex);    
      if (source >= 0) {
         // info flow tracking relevant
         InfoFlowRegion_t ifr;
         ifr = createInfoFlowRegion(source, offset, size);   
         if (!isLocal(regIndex)) 
            addLevel(ifr, offset, size); 
         llvm::errs() << "Adding info flow source in LOAD: " << target->inst << "\n";
         print(ifr);
         std::set<InfoFlowRegion_t> ifrs;
         ifrs.insert(ifr);
         std::map<region, std::set<InfoFlowRegion_t> > ifrmap  = (*currentInfoFlowContext.localIFlow)[target->dest];
         for(auto rtp : notupdated) 
            partitionAndUpdateIFlow(ifrmap, rtp, adjust(ifrs, adjustment(rt, rtp)), true);
         (*currentInfoFlowContext.localIFlow)[target->dest] = ifrmap;
      }
      else if (currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
         // not updated yet with any infoflow so let's see if this refers to an inforelevant address
         std::map<region, std::set<InfoFlowRegion_t> > ifrmap  = (*currentInfoFlowContext.localIFlow)[target->dest];
         for(auto rtp : notupdated) {
            llvm::errs() << "region " << rtp.offset << ":" << rtp.size << "\n";
            //std::map<region, std::set<InfoFlowRegion_t> > ifrmaps2 = slice(currentInfoFlowContext.localIFlow[regIndex], rtp);
            std::map<region, std::set<InfoFlowRegion_t> > ifrmaps2 = (*currentInfoFlowContext.localIFlow)[regIndex];
            std::map<region, std::set<InfoFlowRegion_t> > ifrmaps;
            if (!isLocal(regIndex)) {
               for(auto me : ifrmaps2) {
                  ifrmaps[rtp] = addLevel(me.second, rtp.offset, rtp.size); 
               }
            }
            else ifrmaps = ifrmaps2;
            for(auto me : ifrmaps)  {
               partitionAndUpdateIFlow(ifrmap, rtp, adjust(me.second, adjustment(me.first, rtp)), true);
            }
         }
         (*currentInfoFlowContext.localIFlow)[target->dest] = ifrmap;
      }
   }
}

bool regionsIntersect(region r1, region r2) {
   if (r1.offset <= r2.offset && r1.offset + r1.size - 1 <= r2.offset + r2.size - 1)
      return true;
   if (r2.offset <= r1.offset && r2.offset + r2.size - 1 <= r1.offset + r1.size - 1)
      return true;
   return false;
}

region intersection(region r1, region r2) {
  region r;
  r.size = r.offset = 0;
  if (r1.offset <= r2.offset && r1.offset + r1.size - 1 <= r2.offset + r2.size - 1) {
     r.offset = r2.offset;
     r.size = r1.offset + r1.size - r2.offset;
  }
  if (r2.offset <= r1.offset && r2.offset + r2.size - 1 <= r1.offset + r1.size - 1) {
     r.offset = r1.offset;
     r.size = r2.offset + r2.size - r1.offset;
  }
  return r;
}

region diffRegion(region r1, region r2) {
  region r = r1;
  if (r1.offset == r2.offset) {
     if (r1.size <= r2.size) 
        r.size = 0;
     else {
        r.offset = r1.size + r2.size;
        r.size = r1.size - r2.size;
     } 
  }
  else if (r1.offset < r2.offset && r1.offset + r1.size - 1 <= r2.offset + r2.size - 1) {
     r.offset = r1.offset;
     r.size = r2.offset - r1.offset;
  }
  else if (r2.offset < r1.offset && r2.offset + r2.size - 1 <= r1.offset + r1.size - 1) {
     r.offset = r2.offset + r2.size;
     r.size = r1.offset + r1.size - (r2.offset + r2.size);
  }
  return r;       
}

// pre: all regions in rgs intersect with r1 and they are sorted w.r.t. offset
std::vector<region> diffPartitionRegion(region r1, std::vector<region> rgs) {
  std::vector<region> res;
  region uncovered = r1;
  for(unsigned int i=0; i<rgs.size(); i++) {
     if (uncovered.size <= 0) break;
     region r;
     if (rgs[i].offset == uncovered.offset) {
        uncovered.size -= rgs[i].size;
        uncovered.offset += rgs[i].size;
     }
     else if (rgs[i].offset < uncovered.offset) {
        uncovered.size -=  (rgs[i].offset + rgs[i].size - uncovered.offset);
        uncovered.offset = rgs[i].offset + rgs[i].size;
     }
     else {
        r.offset = uncovered.offset;
        r.size = rgs[i].offset - uncovered.offset;
        res.push_back(r);
        uncovered.offset = rgs[i].offset + rgs[i].size;
        uncovered.size -= (r.size + rgs[i].size);
     }
  }
  if (uncovered.size > 0)
     res.push_back(uncovered);
  return res;
}

region adjustment(region r1, region r2) {
  region r;
  r.offset = r2.offset - r1.offset;  
  r.size = r2.size - r1.size;
  return r;
}

region adjust(region r, region adj) {
   region res;
   res.offset = r.offset + adj.offset;
   res.size = r.size + adj.size;
   return res;
}

std::vector<region> adjust(std::vector<region> r, region adj) {
  std::vector<region> res;
  for(unsigned int i=0; i<r.size(); i++) {
     res.push_back(adjust(r[i], adj));
  }
  return res; 
}

InfoFlowRegion_t adjust(InfoFlowRegion_t ifr, region adj) {
  llvm::errs() << "adj = " << adj.offset << "," << adj.size << "\n";
  InfoFlowRegion_t res;
  res.index = ifr.index;
  for(unsigned int i=0; i<ifr.regions.size(); i++)
     res.regions.push_back(adjust(ifr.regions[i], adj));
  return res;
}

std::set<InfoFlowRegion_t> adjust(std::set<InfoFlowRegion_t> ifrs, region adj) {
  std::set<InfoFlowRegion_t> res;
  for(auto ifr: ifrs) { 
     InfoFlowRegion_t ifr2 = ifr;
     res.insert(adjust(ifr2,adj));
  }
  return res;
}

std::map<region, std::set<InfoFlowRegion_t> > slice(std::map<region, std::set<InfoFlowRegion_t> > ifrmap, region rt) {
  std::map<region, std::set<InfoFlowRegion_t> > res;
  if (rt.size == 0)
     return res;
  region rd;
  std::vector<region> tobesliced;
  std::vector<std::set<InfoFlowRegion_t> > tobeslicedFlow;
  for(auto me : ifrmap) {
     rd = diffRegion(me.first, rt);
     region ri = intersection(me.first, rt);
     if (rd.size == 0) {
        res[me.first] = ifrmap[me.first];
     }
     else if (ri.size > 0) {
        tobesliced.push_back(me.first);
        tobeslicedFlow.push_back(me.second); 
     }
     // otherwise drop it completely
  }
  for(unsigned int i=0; i<tobesliced.size(); i++) {
     region ri = intersection(tobesliced[i], rt);
     region rd1 = diffRegion(tobesliced[i], rt);
     region adj = adjustment(tobesliced[i], rd1);
     std::set<InfoFlowRegion_t> ifrus;
     for(auto tbsifr : tobeslicedFlow[i]) {
        InfoFlowRegion_t ifru;
        ifru.index = tbsifr.index;
        for(unsigned int j=0; j<tbsifr.regions.size(); j++)
           ifru.regions.push_back(adjust(tbsifr.regions[j], adj));
        ifrus.insert(ifru);
     }
     res[ri] = ifrus;
  }
  return res;
} 

void partitionAndUpdateIFlow(std::map<region, std::set<InfoFlowRegion_t> > &ifrmap, 
                                          region rt, std::set<InfoFlowRegion_t> ifrcs, bool replace) {

  bool exactMatch = false;
  std::set<InfoFlowRegion_t> rgs;
  for(auto me : ifrmap) {
     if (me.first == rt) {
        exactMatch = true;
        rgs = me.second;
        break;
     }
  }
  if (exactMatch) {
     if (replace)  {
        ifrmap[rt] = ifrcs;
        llvm::errs() << "exact match, setting region " << rt.offset << ":" << rt.size << "to:\n";
        print(ifrcs);
     }
     else {
        llvm::errs() << "exact match, expanding info flow:\n";
        print(ifrcs);
        for(auto rgse : rgs) {
           ifrcs.insert(rgse);
        } 
        llvm::errs() << "into:\n";
        print(ifrcs);
        ifrmap[rt] = ifrcs;
     }
  }
  else {
     std::vector<region> covered;
     std::vector<std::set<InfoFlowRegion_t> > infr;
     for(auto me : ifrmap) {
        if (regionsIntersect(me.first, rt)) { 
           covered.push_back(me.first);
           infr.push_back(me.second);
        }  
     }
     std::vector<region> toberemoved;
     for(unsigned int i=0; i<covered.size(); i++) {
        ifrmap.erase(covered[i]);
        region rd1 = diffRegion(covered[i], rt);
        if (rd1.size > 0)  
           ifrmap[rd1] = adjust(infr[i], adjustment(covered[i], rd1));
        //region rd2 = diffRegion(rt, covered[i]);
        //if (rd2.size > 0)    
        //   ifrmap[rd2] = adjust(ifrcs, adjustment(rt, covered[i]));
        region rd3 = intersection(covered[i], rt);
        if (rd3.size > 0) {
           toberemoved.push_back(rd3);
           if (replace) {
              ifrmap[rd3] = adjust(ifrcs, adjustment(rt, rd3));
              llvm::errs() << "setting common subregion " << rd3.offset << ":" << rd3.size << "to:\n";
              print(ifrmap[rd3]);
           }
           else {
              llvm::errs() << "expanding info flow:\n";
              std::set<InfoFlowRegion_t> aifrcs = adjust(ifrcs, adjustment(rt, rd3));
              print(aifrcs);              
              for(auto infre: infr[i]) 
                 aifrcs.insert(adjust(infre, adjustment(covered[i], rd3)));
              ifrmap[rd3] = aifrcs;          
              llvm::errs() << "into:\n";
              print(aifrcs);               
           }
        }
     }
     if (covered.size() > 0) {
        std::vector<region> rts = diffPartitionRegion(rt, toberemoved);
        for(unsigned int k=0; k<rts.size(); k++) {
           ifrmap[rts[k]] = adjust(ifrcs, adjustment(rt, rts[k]));
           llvm::errs() << "setting partitioned region " << rts[k].offset << "," << rts[k].size << " :\n";
           print(ifrmap[rts[k]]);
        }     
     }
     else { //if (covered.size() == 0) {
        ifrmap[rt] = ifrcs;
        llvm::errs() << "setting target region " << rt.offset << ":" << rt.size << "to:\n";
        print(ifrcs);
     }
  }
}


void UpdateIFlow(std::map<region, std::set<InfoFlowRegion_t> > &ifrmap, 
                     std::map<region, std::set<InfoFlowRegion_t> > ifrmaps, int offsetAdj, bool replace) {
    for(auto me : ifrmaps) {
        region rt;
        rt.offset = me.first.offset + offsetAdj;
        rt.size = me.first.size;
        partitionAndUpdateIFlow(ifrmap, rt, me.second, replace);
    }
}

void Executor::updateInfoFlowForGeptr(ExecutionState &state,
                                              int regIndex, 
                                      KInstruction *target,
                                             int offset) {
   if (!infoFlowSummaryMode) return;
   if (regIndex < 0) return; 
   updateInfoFlowDirectCopy(state, regIndex, target);
   /*
   if (currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
      std::set<InfoFlowRegion_t> ifrs, ifrs2;
      for(auto me : (*currentInfoFlowContext.localIFlow)[regIndex]) {
         ifrs = me.second;
         break;
      }
      int size = getWidthForLLVMType(target->inst->getType());
      ifrs2 = addLevel(ifrs, offset, size);
      std::map<region, std::set<InfoFlowRegion_t> > ifrmap;
      region rt; rt.offset = 0; rt.size = size;
      ifrmap[rt] = ifrs2;
      (*currentInfoFlowContext.localIFlow)[target->dest] = ifrmap;
   }*/
}
 
void Executor::updateInfoFlowForStore(ExecutionState &state, 
                                     int regIndex, 
                                 int destregIndex, 
                                 const MemoryObject *mo, 
                             KInstruction *target, 
                             ref<Expr> offsetexpr, 
                                    unsigned size) {
   if (!infoFlowSummaryMode) return;
   //if (regIndex < 0) return; 
   ConstantExpr *CE = dyn_cast<ConstantExpr>(offsetexpr);
   unsigned offset;
   if (!CE)
      offset = 0;
   else offset = CE->getZExtValue();
   region rs;
   rs.offset = 0;
   rs.size = size;
   region rt;
   rt.offset = offset;
   rt.size = size;
   InfoFlowRegion_t destif, sourceif;
   std::set<InfoFlowRegion_t> destifs, sourceifs;
   bool record = false;
   bool doublepointer = false;
   llvm::StoreInst *li = dyn_cast<llvm::StoreInst>(target->inst);
   if (!li) return;
   Type *t = li->getPointerOperand()->getType();
   if (t->isPointerTy()) {
      t = t->getPointerElementType();
      if (t->isPointerTy())
            doublepointer = true;
   }
   llvm::errs() << "Info Flow For STORE register=" << regIndex << "\n";
   int dest = isInfoFlowRelevant(target, destregIndex); 
   if (dest >= 0) {
      // info flow tracking relevant
      destif = createInfoFlowRegion(dest, offset, size);  
      llvm::errs() << "Adding info flow relevant destination in STORE: " << target->inst << "\n";
      destifs = setIF(destif);
      print(destifs);
      record = true;
   }
   else if (currentInfoFlowContext.localIFlow->find(destregIndex) != currentInfoFlowContext.localIFlow->end()) {
      record = true;
      for(auto de : (*currentInfoFlowContext.localIFlow)[destregIndex]) {
         destifs = de.second;
         if (!isLocal(destregIndex))
            destifs = addLevel(destifs, offset, size);
         record = true;
         llvm::errs() << "Adding info flow relevant destination from register in STORE: " << target->inst << "\n";
         print(destifs);
         break;
      }
   } 
   int source = isInfoFlowRelevant(target, regIndex); 
   if (source >= 0  || currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
      std::map<region, std::set<InfoFlowRegion_t> > ifrmap, ifrmaps;
      if (source >= 0) {
         sourceif = createInfoFlowRegion(source, offset, size);   
         llvm::errs() << "Adding info flow relevant source in STORE: " << target->inst << "\n";
         sourceifs = setIF(sourceif);
         print(sourceifs);
         ifrmaps[rs] = sourceifs;
      }
      else {
         ifrmaps = slice((*currentInfoFlowContext.localIFlow)[regIndex], rs);
      }
      std::map<const MemoryObject*, 
                  std::map<region, 
                           std::set<InfoFlowRegion_t> > > memoryIFlow = memoryInfoFlow[&state];
      if (memoryIFlow.find(mo) != memoryIFlow.end())
         ifrmap = memoryIFlow[mo];  
      UpdateIFlow(ifrmap, ifrmaps, rt.offset - rs.offset, true);      
      memoryIFlow[mo] = ifrmap;
      memoryInfoFlow[&state] = memoryIFlow; 
      if (record) {
         for(auto dc : destifs) {
            for(auto se : ifrmaps) {
               for(auto see : se.second) {
                  recordInfoFlow(state, dc, see); 
               }
            }
         }
      }
   }
   else if (record) {
      llvm::errs() << "CLEARING INFO FLOW\n";
      // clear the info flow to the destif
      for(auto destif : destifs)
         clearInfoFlowSummaryPerState(state, destif);
   }
}

int getReturnIndex(Function *f) {
   unsigned int argi = 0;
   for(llvm::Function::arg_iterator ai = f->arg_begin(); ai != f->arg_end(); ai++, argi++);
   return argi;
}

void Executor::updateInfoFlowForReturn(ExecutionState &state, int regIndex, KInstruction *ki) {
   llvm::errs() << "Info Flow for RETURN\n";
   if (!infoFlowSummaryMode) return;
   if (regIndex < 0) return; 
   if (ki->inst->getNumOperands() > 0) {
      int source = isInfoFlowRelevant(ki, regIndex);
      if (source >=0 || currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
         Type *rt = ki->inst->getOperand(0)->getType(); 
         if (source >=0) {
             InfoFlowRegion_t  destif = createInfoFlowRegion(getReturnIndex(infoFlowSummarizedFunc), 
                                                       0, getWidthForLLVMType(rt));
             InfoFlowRegion_t sourceif = createInfoFlowRegion(source, 0, getWidthForLLVMType(rt));  
             recordInfoFlow(state, destif, sourceif);
         }
         else {
            std::map<region, std::set<InfoFlowRegion_t> > ifrmap = (*currentInfoFlowContext.localIFlow)[regIndex];
            for(auto me : ifrmap) {
               InfoFlowRegion_t destif = createInfoFlowRegion(getReturnIndex(infoFlowSummarizedFunc), 
                                                       me.first.offset, me.first.size);
               for(auto mee : me.second) {
                  recordInfoFlow(state, destif, mee);
               }
            }     
        } 
      }  
   }
}


// As    t = t->getPointerElementType();
      if (t->isPointerTy())
            doublepointer = true;
   }
   llvm::errs() << "Info Flow For STORE register=" << regIndex << "\n";
   int dest = isInfoFlowRelevant(target, destregIndex); 
   if (dest >= 0) {
      // info flow tracking relevant
      destif = createInfoFlowRegion(dest, offset, size);  
      llvm::errs() << "Adding info flow relevant destination in STORE: " << target->inst << "\n";
      destifs = setIF(destif);
      print(destifs);
      record = true;
   }
   else if (currentInfoFlowContext.localIFlow->find(destregIndex) != currentInfoFlowContext.localIFlow->end()) {
      record = true;
      for(auto de : (*currentInfoFlowContext.localIFlow)[destregIndex]) {
         destifs = de.second;
         if (!isLocal(destregIndex))
            destifs = addLevel(destifs, offset, size);
         record = true;
         llvm::errs() << "Adding info flow relevant destination from register in STORE: " << target->inst << "\n";
         print(destifs);
         break;
      }
   } 
   int source = isInfoFlowRelevant(target, regIndex); 
   if (source >= 0  || currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
      std::map<region, std::set<InfoFlowRegion_t> > ifrmap, ifrmaps;
      if (source >= 0) {
         sourceif = createInfoFlowRegion(source, offset, size);   
         llvm::errs() << "Adding info flow relevant source in STORE: " << target->inst << "\n";
         sourceifs = setIF(sourceif);
         print(sourceifs);
         ifrmaps[rs] = sourceifs;
      }
      else {
         ifrmaps = slice((*currentInfoFlowContext.localIFlow)[regIndex], rs);
      }
      std::map<const MemoryObject*, 
                  std::map<region, 
                           std::set<InfoFlowRegion_t> > > memoryIFlow = memoryInfoFlow[&state];
      if (memoryIFlow.find(mo) != memoryIFlow.end())
         ifrmap = memoryIFlow[mo];  
      UpdateIFlow(ifrmap, ifrmaps, rt.offset - rs.offset, true);      
      memoryIFlow[mo] = ifrmap;
      memoryInfoFlow[&state] = memoryIFlow; 
      if (record) {
         for(auto dc : destifs) {
            for(auto se : ifrmaps) {
               for(auto see : se.second) {
                  recordInfoFlow(state, dc, see); 
               }
            }
         }
      }
   }
   else if (record) {
      llvm::errs() << "CLEARING INFO FLOW\n";
      // clear the info flow to the destif
      for(auto destif : destifs)
         clearInfoFlowSummaryPerState(state, destif);
   }
}

int getReturnIndex(Function *f) {
   unsigned int argi = 0;
   for(llvm::Function::arg_iterator ai = f->arg_begin(); ai != f->arg_end(); ai++, argi++);
   return argi;
}

void Executor::updateInfoFlowForReturn(ExecutionState &state, int regIndex, KInstruction *ki) {
   llvm::errs() << "Info Flow for RETURN\n";
   if (!infoFlowSummaryMode) return;
   if (regIndex < 0) return; 
   if (ki->inst->getNumOperands() > 0) {
      int source = isInfoFlowRelevant(ki, regIndex);
      if (source >=0 || currentInfoFlowContext.localIFlow->find(regIndex) != currentInfoFlowContext.localIFlow->end()) {
         Type *rt = ki->inst->getOperand(0)->getType(); 
         if (source >=0) {
             InfoFlowRegion_t  destif = createInfoFlowRegion(getReturnIndex(infoFlowSummarizedFunc), 
                                                       0, getWidthForLLVMType(rt));
             InfoFlowRegion_t sourceif = createInfoFlowRegion(source, 0, getWidthForLLVMType(rt));  
             recordInfoFlow(state, destif, sourceif);
         }
         else {
            std::map<region, std::set<InfoFlowRegion_t> > ifrmap = (*currentInfoFlowContext.localIFlow)[regIndex];
            for(auto me : ifrmap) {
               InfoFlowRegion_t destif = createInfoFlowRegion(getReturnIndex(infoFlowSummarizedFunc), 
                                                       me.first.offset, me.first.size);
               for(auto mee : me.second) {
                  recordInfoFlow(state, destif, mee);
               }
            }     
        } 
      }  
   }
}


// As